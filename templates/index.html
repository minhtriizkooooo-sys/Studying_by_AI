import os, random, qrcode, io, base64, time, pandas as pd
from flask import Flask, render_template, request, send_file
from flask_socketio import SocketIO, emit

app = Flask(__name__)
app.config['SECRET_KEY'] = 'marie_curie_2026_sync'
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='gevent')

# Quản lý trạng thái trò chơi
game_state = {
    "all_questions": [], "used_indices": set(), "current_round_qs": [],
    "players": {}, "player_names": set(), "active_q_idx": -1,
    "current_round_num": 0, "start_time": 0, "pin": None,
    "is_running": False, "king_sid": None, "current_answers": {},
    "timer_id": 0 # Để định danh phiên làm việc của timer
}

@app.route('/')
def index(): return render_template('index.html')

@app.route('/template')
def download_template():
    df = pd.DataFrame(columns=['Câu hỏi', 'Đáp án A', 'Đáp án B', 'Đáp án C', 'Đáp án D', 'Đáp án đúng', 'Giải thích'])
    df.loc[0] = ["1+1 bằng mấy?", "1", "2", "3", "4", "2", "Phép tính cơ bản 1 cộng 1 là 2."]
    out = io.BytesIO()
    with pd.ExcelWriter(out, engine='xlsxwriter') as writer:
        df.to_excel(writer, index=False)
    out.seek(0)
    return send_file(out, as_attachment=True, download_name="mau_cau_hoi.xlsx")

@socketio.on('host_upload_file')
def handle_upload(data):
    try:
        header, encoded = data['content'].split(",", 1)
        file_bytes = base64.b64decode(encoded)
        df = pd.read_excel(io.BytesIO(file_bytes)) if 'excel' in header or 'spreadsheet' in header else pd.read_csv(io.BytesIO(file_bytes), encoding='utf-8-sig')
        game_state.update({"all_questions": df.to_dict('records'), "pin": str(random.randint(100000, 999999))})
        qr = qrcode.QRCode(box_size=10, border=2); qr.add_data(game_state['pin']); qr.make(fit=True)
        buf = io.BytesIO(); qr.make_image().save(buf, format='PNG')
        emit('qr_ready', {'qr': base64.b64encode(buf.getvalue()).decode('utf-8'), 'pin': game_state['pin']})
    except: emit('error', {'msg': 'Lỗi đọc file. Vui lòng dùng file mẫu!'})

@socketio.on('join_request')
def join(data):
    name, pin = str(data.get('name', '')).strip(), str(data.get('pin', '')).strip()
    if pin == game_state['pin'] and name not in game_state['player_names']:
        game_state['players'][request.sid] = {"name": name, "total": 0, "last_pts": 0, "history": [], "approved": False}
        game_state['player_names'].add(name); emit('new_player_waiting', {'name': name, 'sid': request.sid}, broadcast=True)
    else: emit('join_failed', {'msg': 'Sai PIN hoặc tên trùng'})

@socketio.on('approve_all')
def approve_all():
    for s in game_state['players']: game_state['players'][s]['approved'] = True
    emit('approved_success', broadcast=True); update_lb()

@socketio.on('start_next_round')
def start_round():
    if len(game_state['all_questions']) < 10: return emit('error', {'msg': 'Cần ít nhất 10 câu!'})
    game_state['current_round_num'] += 1
    avail = [i for i in range(len(game_state['all_questions'])) if i not in game_state['used_indices']]
    if len(avail) < 10: game_state['used_indices'].clear(); avail = list(range(len(game_state['all_questions'])))
    selected = random.sample(avail, 10); game_state['used_indices'].update(selected)
    game_state['current_round_qs'] = [game_state['all_questions'][i] for i in selected]
    game_state['active_q_idx'] = 0; game_state['is_running'] = True; send_q()

def send_q():
    idx = game_state['active_q_idx']
    if idx >= 10 or not game_state['is_running']:
        game_state['is_running'] = False; socketio.emit('enable_review'); return
    
    game_state['current_answers'] = {}
    game_state['start_time'] = time.time()
    game_state['timer_id'] += 1
    current_timer = game_state['timer_id']
    
    q = game_state['current_round_qs'][idx]
    socketio.emit('new_q', {'q': q, 'idx': idx + 1, 'round': game_state['current_round_num']})
    
    # Auto-advance sau 15.5 giây
    socketio.sleep(15.5)
    if game_state['is_running'] and game_state['active_q_idx'] == idx and game_state['timer_id'] == current_timer:
        game_state['active_q_idx'] += 1; send_q()

@socketio.on('submit_ans')
def handle_sub(data):
    sid = request.sid
    if not game_state['is_running'] or sid in game_state['current_answers']: return
    
    p = game_state['players'][sid]
    q = game_state['current_round_qs'][game_state['active_q_idx']]
    elapsed = time.time() - game_state['start_time']
    
    is_correct = str(data['ans']).strip().lower() == str(q['Đáp án đúng']).strip().lower()
    pts = max(10, int(100 * (1 - elapsed/15))) if is_correct else 0
    
    # Event: Lucky Spin & Steal
    if is_correct:
        is_fastest = not any(v.get('correct') for v in game_state['current_answers'].values())
        if is_fastest:
            bonus = random.randint(15, 30); pts += bonus
            socketio.emit('special_event', {'type': 'lucky', 'name': p['name'], 'val': bonus})
            if game_state['king_sid'] and game_state['king_sid'] != sid:
                stolen = int(game_state['players'][game_state['king_sid']]['total'] * 0.15)
                game_state['players'][game_state['king_sid']]['total'] -= stolen
                pts += stolen
                socketio.emit('special_event', {'type': 'steal', 'msg': f"⚡ {p['name']} cướp {stolen}đ từ {game_state['players'][game_state['king_sid']]['name']}!"})

    p['total'] += pts; p['last_pts'] = pts
    p['history'].append({
        "vong": game_state['current_round_num'], "cau": game_state['active_q_idx'] + 1,
        "q": q['Câu hỏi'], "options": [str(q['Đáp án A']), str(q['Đáp án B']), str(q['Đáp án C']), str(q['Đáp án D'])],
        "u": data['ans'], "c": q['Đáp án đúng'], "ex": q['Giải thích'], "pts": pts
    })
    
    game_state['current_answers'][sid] = {'correct': is_correct}
    game_state['king_sid'] = max(game_state['players'], key=lambda x: game_state['players'][x]['total'])
    update_lb()
    
    # Tự động chuyển câu nếu tất cả đã trả lời
    approved_count = len([s for s in game_state['players'] if game_state['players'][s]['approved']])
    if len(game_state['current_answers']) >= approved_count:
        game_state['active_q_idx'] += 1; socketio.sleep(1); send_q()

def update_lb():
    lb = sorted([{"name": p['name'], "total": p['total'], "last": p['last_pts']} for p in game_state['players'].values() if p['approved']], key=lambda x: x['total'], reverse=True)
    socketio.emit('lb_update', lb)

@socketio.on('get_review')
def get_review():
    if request.sid in game_state['players']: emit('render_review', game_state['players'][request.sid]['history'])

@socketio.on('finish_all')
def finish():
    game_state['is_running'] = False; socketio.emit('enable_review')

if __name__ == '__main__': socketio.run(app, host='0.0.0.0', port=5000)
